# Квантификаторы +, *, ? и {n}

Рассмотрим ту же задачу, что и ранее -- взять телефон вида `+7(903)-123-45-67` и найти все числа в нём. Но теперь нас интересуют не цифры по отдельности, а именно числа, то есть результат вида `7, 903, 123, 45, 67`.

Для поиска цифр по отдельности нам было достаточно класса `\d`. Но здесь нужно искать *числа* -- последовательности из 1 или более цифр.

## Количество {n}

Количество повторений символа можно указать с помощью числа в фигурных скобках: `{n}`.

Такое указание называют *квантификатором* (от англ. quantifier).

У него есть несколько подформ записи:

Точное количество: `{5}`
: Регэксп <code class="pattern">\d{5}</code> обозначает ровно 5 цифр, в точности как <code class="pattern">\d\d\d\d\d</code>.

    Следующий пример находит пятизначное число.

    ```js run
    alert( "Мне 12345 лет".match(/\d{5}/) ); //  "12345"
    ```

Количество от-до: `{3,5}`
: Для того, чтобы найти, например, числа размером от трёх до пяти знаков, нужно указать границы в фигурных скобках: <code class="pattern">\d{3,5}</code>

    ```js run
    alert( "Мне не 12, а 1234 года".match(/\d{3,5}/) ); // "1234"
    ```

    Последнее значение можно и не указывать. Тогда выражение <code class="pattern">\d{3,}</code> найдет числа, длиной от трех цифр:

    ```js run
    alert( "Мне не 12, а 345678 лет".match(/\d{3,5}/) ); // "345678"
    ```

В случае с телефоном нам нужны числа -- одна или более цифр подряд. Этой задаче соответствует регулярное выражение <code class="pattern">\d{1,}</code>:

```js run
var str = "+7(903)-123-45-67";

alert( str.match(/\d{1,}/g) ); // 7,903,123,45,67
```

## Короткие обозначения

Для самые часто востребованных квантификаторов есть специальные короткие обозначения.

`+`
: Означает "один или более", то же что `{1,}`.

    Например, <code class="pattern">\d+</code> находит числа -- последовательности из 1 или более цифр:

    ```js run
    var str = "+7(903)-123-45-67";

    alert( str.match(/\d+/g) ); // 7,903,123,45,67
    ```

`?`
: Означает "ноль или один", то же что и `{0,1}`. По сути, делает символ необязательным.

    Например, регэксп <code class="pattern">ou?r</code> найдёт <code class="match">o</code>, после которого, возможно, следует <code class="match">u</code>, а затем <code class="match">r</code>.

    Этот регэксп найдёт <code class="match">or</code> в слове <code class="subject">color</code> и <code class="match">our</code> в <code class="subject">colour</code>:

    ```js run
    var str = "Можно писать color или colour (британский вариант)";

    alert( str.match(/colou?r/g) ); // color, colour
    ```

`*`
: Означает "ноль или более", то же что `{0,}`. То есть, символ может повторяться много раз или вообще отсутствовать.

    Пример ниже находит цифру, после которой идёт один или более нулей:

    ```js run
    alert( "100 10 1".match(/\d0*/g) ); // 100, 10, 1
    ```

    Сравните это с `'+'` (один или более):

    ```js run
    alert( "100 10 1".match(/\d0+/g) ); // 100, 10
    ```

## Ещё примеры

Эти квантификаторы принадлежат к числу самых важных "строительных блоков" для сложных регулярных выражений, поэтому мы рассмотрим ещё примеры.

Регэксп "десятичная дробь" (число с точкой внутри): <code class="pattern">\d+\.\d+</code>
: В действии:
    ```js run
    alert( "0 1 12.345 7890".match(/\d+\.\d+/g) ); // 12.345
    ```

Регэксп "открывающий HTML-тег без атрибутов", такой как `<span>` или `<p>`: <code class="pattern">/&lt;[a-z]+&gt;/i</code>
: Пример:

    ```js run
    alert( "<BODY> ... </BODY>".match(/<[a-z]+>/gi) ); // <BODY>
    ```

    Это регулярное выражение ищет символ <code class="pattern">'&lt;'</code>, за которым идут одна или более букв английского алфавита, и затем <code class="pattern">'&gt;'</code>.

Регэксп "открывающий HTML-тег без атрибутов" (лучше): <code class="pattern">/&lt;[a-z][a-z0-9]*&gt;/i</code>
: Здесь регулярное выражение расширено: в соответствие со стандартом, HTML-тег может иметь символ на любой позиции, кроме первой, например `<h1>`.

    ```js run
    alert( "<h1>Привет!</h1>".match(/<[a-z][a-z0-9]*>/gi) ); // <h1>
    ```

Регэксп "открывающий или закрывающий HTML-тег без атрибутов": <code class="pattern">/&lt;\/?[a-z][a-z0-9]*&gt;/i</code>
: В предыдущий паттерн добавили необязательный слэш <code class="pattern">/?</code> перед тегом. Его понадобилось заэкранировать, чтобы JavaScript не принял его за конец шаблона.

    ```js run
    alert( "<h1>Привет!</h1>".match(/<\/?[a-z][a-z0-9]*>/gi) ); // <h1>, </h1>
    ```

```smart header="Точнее -- значит сложнее"
В этих примерах мы видим общее правило, которое повторяется из раза в раз: чем точнее регулярное выражение, тем оно длиннее и сложнее.

Например, для HTML-тегов, скорее всего, подошло бы и более короткое регулярное выражение <code class="pattern">&lt;\w+&gt;</code>.

Так как класс `\w` означает "любая цифра или английская буква или `'_'`, то под такой регэксп подойдут и не теги, например <code class="match">&lt;_&gt;</code>. Однако он гораздо проще, чем более точный регэксп <code class="pattern">&lt;[a-z][a-z0-9]*&gt;</code>.

Подойдёт ли нам <code class="pattern">&lt;\w+&gt;</code> или нужно использовать именно <code class="pattern">&lt;[a-z][a-z0-9]*&gt;</code>?

В реальной жизни допустимы оба варианта. Ответ на подобные вопросы зависит от того, насколько реально важна точность и насколько сложно потом будет отфильтровать лишние совпадения (если появятся).
```

