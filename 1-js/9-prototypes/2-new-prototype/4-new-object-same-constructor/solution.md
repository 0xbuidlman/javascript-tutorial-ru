Да, можем, но только если уверены, что кто-то позаботился о том, чтобы значение `constructor` было верным.

В частности, без вмешательства в прототип код точно работает, например:

```js run
function User(name) {
  this.name = name;
}

var obj = new User('Вася');
var obj2 = new obj.constructor('Петя');

alert( obj2.name ); // Петя (сработало)
```

Сработало, так как `User.prototype.constructor == User`.

Но если кто-то, к примеру, перезапишет `User.prototype` и забудет указать `constructor`, то такой фокус не пройдёт, например:

```js run
function User(name) {
    this.name = name;
  }
*!*
User.prototype = {}; // (*)
*/!*

var obj = new User('Вася');
var obj2 = new obj.constructor('Петя');

alert( obj2.name ); // undefined
```

Почему obj2.name равен undefined? Вот как это работает:

1. При вызове new obj.constructor('Петя'), obj ищет у себя свойство constructor - не находит.
2. Обращается к своему скрытому свойству __proto__, которое ведёт к прототипу.
3. Прототипом будет (*)
4. Далее здесь также ищется свойство constructor - его нет.
5. Где ищем дальше? Правильно - у следующего прототипа выше, а им будет Object ({}), не путать с функцией-конструктором Object.
6. У Object ({}) есть constructor, поэтому происходит вызов такого плана: {}.constructor('Петя') или конкретнее: obj.__proto__.__proto__.constructor('Петя').
7. Этот метод возвратит объект-обёртку. В зависимости от переданного аргумента будет определятся тип объекта-обёртки, в нашем случае была передана строка 'Петя', значит будет возвращено: String {0: "П", 1: "е", 2: "т", 3: "я", length: 4, [[PrimitiveValue]]: "Петя"} (в Chrome), как будто мы вызвали new String('Петя'). Если бы мы передали число 5, то возвратилось: Number {[[PrimitiveValue]]: 5} и так далее.
8. Поэтому obj2.name равен undefined, так как, у String {0: "П", 1: "е", 2: "т", 3: "я", length: 4, [[PrimitiveValue]]: "Петя"} нету свойства name.
